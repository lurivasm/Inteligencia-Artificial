%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Ejercicio 1
% Duplica
% Recibe dos listas, y es true si los elementos de la primera 
% estan en la segunda duplicados

% Caso base : dos listas vacías son iguales 
duplica([],[]).

% Solamente le pasamos el primer elemento dos veces a la
% función, llamándola con el resto de la lista y hasta que se vacíe
duplica([X|L],[X, X|L1]) :- duplica(L, L1).

 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Ejercicio 2
% Invierte
% Recibe dos listas y se satisface cuando la segunda contiene los
% elementos de la primera en orden inverso
% Hacemos uso del predicado concatena
concatena([], L, L).
concatena([X|L1], L2, [X|L3]) :- concatena(L1, L2, L3).

% Caso base : dos listas vacías
invierte([], []).

% Invertimos el resto de la primera lista y lo concatenamos
% en L con su primer elemento dado la vuelta
invierte([H|T], L) :- invierte(T, R), concatena(R, [H], L).

 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Ejercicio 3
% Palíndromo
% Recibe una lista y se satisface cuando es un palindromo, es
% decir, se lee de la misma manera de izquierda a derecha que
% de derecha a izquierda
% 
% Solamente hay que comprobar que L coincide con ella misma invertida
palindromo(L) :- invierte(L, L).

 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Ejercicio 4
% Divide
%  Recibe 4 argumentos:
%  		L : una lista de elementos
%  		N : un numero
%  		L1 : lista que debe contener los N primeros elem de L
%  		L2 : lista que contiene el resto de elem de L
% Se satisface cuando la lista L1 contiene los primeros N 
% elementos de L y L2 contiene el resto.
% 
% La longitud de L1 debe ser N y L es la concatenación de L1 y L2
divide(L, N, L1, L2) :- length(L1, N), concatena(L1, L2, L).

 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Ejercicio 5
% Aplasta
% Recibe dos listas y se satisface cuando la segunda lista es 
% una versión aplastada de la primera

% Caso base : dos listas vacías ya no se pueden aplastar más 
aplasta([], []) :- !.

% Si T es una lista, aplastamos T en L2 y H en L3, concatenándolas
% después en L1
aplasta([T|H], L1) :- is_list(T), aplasta(T, L2), 
    				  aplasta(H, L3), concatena(L2, L3, L1).

% Si T no es una lista, es decir, es un elemento, y es el primer
% elemento de L, solamente aplastamos H en L 
aplasta([T|H], [T|L]) :- \+ is_list(T), aplasta(H, L). 
 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Ejercicio 6
% Primos
% Recibe un número N y una lista L
% Se satisface cuando L contiene los factores primos de N
next_factor(_, 2, 3) :- !.
next_factor(N, F, NF) :-  F < N, NF is F + 2.

% Caso base : cuando N es 1 ya no podemos dividirlo más
divisores(1, [], _) :- !.

% Si F es divisor de N, lo mete en L, y calcula los divisores
% de N/F
divisores(N, [F|L], F) :- 0 is mod(N, F),
    				  N2 is N/F, divisores(N2, L, F).

% Si F no es divisor de N, calcula el siguiente factor despues 
% de F (NF) y mira si es divisor de N
divisores(N, L, F) :- \+ 0 is mod(N, F), next_factor(N, F, NF),
    				  divisores(N, L, NF).

% Función principal que empieza probando el 2 como divisor
primos(N, L) :- N > 0, divisores(N, L, 2). 


 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Ejercicio 7.1
% cod_primero(X, L, Lrem, Lfront)
% 
% Recibe un número X, repetido o no en la lista L, de modo
% que Lfront contiene X y sus repeticiones en L, y Lrem 
% contiene el resto de L

% Caso base : L y Lrem están vacías y Lfront solo contiene X
cod_primero(X, [], [], [X]).

% Si X es igual que P lo metemos en Lfront y llamamos a la función
% recursivamente con el resto de L (F)
cod_primero(X, [P|F], Lrem, [T|Lfront]) :- X == P, T is P,
    									cod_primero(X, F, Lrem, Lfront).

% El otro caso posible es que X sea distinto de P, entonces hemos 
% acabado. Llamamos a Lrem lo que quede de L y metemos la X en Lfront
cod_primero(X, [P|F], Lrem, [T]) :- \+ X == P , Lrem = [P|F], T is X.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Ejercicio 7.2
% cod_all(L, L1)
% Recibe dos listas : 
% 	- L es una lista de números repetidos o no, por ejemplo [1, 2, 2, 3]
% 	- L1 es una lista de listas, en la que cada sublista se forma por 
% 	  la repetición de los números, por ejemplo [[1], [2,2],[3]]

% Caso base : dos listas vacías son iguales 
cod_all([],[]).

% Con cada elemento de la primera lista, llamamos a cod_primero, metiendo
% cada lista Lfront en L1
cod_all([P|L],[T|L1]) :- cod_primero(P, L, Lrem, Lfront), T = Lfront, cod_all(Lrem, L1).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Ejercicio 7.3
% run_length(L, L1)
% Recibe dos listas :
% 	- L es una lista de números repetidos o no, por ejemplo [1, 2, 2, 3]
% 	- L1 es la lista de sublistas que contiene cuántas veces aparece
% 	  cada dígito de la lista, por ejemplo, [[1,1], [2,2], [1,3]]

% Función que devuelve el primer elemento de una lista
first([P|_], P).

% Caso base : dos listas vacías
aux([], []).

% Función auxiliar que descompone una lista de listas en el tamaño y 
% el elemento de la lista
aux([P|F], [P1|F1]) :- length(P, N), first(P, H), P1 = [N,H], aux(F, F1).

% Función principal que llama a cod_all pasándole su resultado
% a la función auxiliar que la descompone
run_length(L, L1) :- cod_all(L, L2), aux(L2, L1).

 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Ejercicio 8
% cod_
% 
% 














